---
title: "ASUbuildR"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
runtime: shiny
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# Figure out full paths to src/ C++ files, going up two levels
src_cpp_files <- c("choose_best_neighbor.cpp",
                   "build_edges.cpp",
                   "choose_best_drop.cpp")

src_paths <- normalizePath(file.path("..", "..", "src", src_cpp_files),
                           winslash = "/", mustWork = FALSE)

# Check that all source files are there
in_repo <- all(file.exists(src_paths))

maybe_sourceCpp <- function(fun, path) {
  if (!exists(fun, mode = "function") && file.exists(path)) {
    message("Compiling ", basename(path))
    Rcpp::sourceCpp(path)
  }
}

if (in_repo) {
  message("→ Dev mode: compiling C++ helpers from src/")
  maybe_sourceCpp("choose_best_neighbor", src_paths[1])
  maybe_sourceCpp("build_edges",          src_paths[2])
  maybe_sourceCpp("choose_best_drop",     src_paths[3])
} else {
  message("→ Installed package mode (shared library already loaded)")

}

# ---- dev mode: source helper functions relative to this file ----------
is_dev_mode <- file.exists("../../DESCRIPTION") && dir.exists("../../R")

if (is_dev_mode) {
  message("→ Dev mode: sourcing from ../../R/")
  r_dir <- normalizePath("../../R", winslash = "/", mustWork = TRUE)

  source(file.path(r_dir, "run_tract_hunter.R"))
  source(file.path(r_dir, "run_asu_original.r"))
} else {
  message("→ Installed package mode: functions should already be available")
}


## ---- tigris cache ----------------------------------------------------
## put cached TIGER/Line ZIPs in a per-user cache folder that is always
## writable, even after the package is installed read-only.

# 1. choose a sensible user-cache path (rappdirs works everywhere)
cache_dir <- rappdirs::user_cache_dir("ASUbuildR", "tigris")

# 2. create it if it doesn't exist
if (!dir.exists(cache_dir))
  dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)

# 3. tell tigris to use it *this session*
options(tigris_cache_dir = cache_dir)

# tell tigris to look there first before re‑downloading
options(tigris_use_cache = TRUE)


# cache every tigris download automatically
options(
  tigris_use_cache = TRUE,                 # turn caching on
  tigris_class     = "sf"                  # always return sf objects
)

options(shiny.maxRequestSize = 50 * 1024^2)  # Set to 50MB or your desired limit

# Initialize reactive values
uploaded_data <- shiny::reactiveVal(NULL)
state <- shiny::reactiveVal(NULL)
tract_year <- shiny::reactiveVal(NULL)
tract_data <- shiny::reactiveVal(NULL)
asu_data <- shiny::reactiveVal(NULL)
asu_tracts <- shiny::reactiveVal(NULL)
asu_summary <- shiny::reactiveVal(NULL)
full_data <- shiny::reactiveVal(NULL)
full_data_reset <- shiny::reactiveVal()
selected_tracts <- shiny::reactiveVal(NULL)
edit_table <- shiny::reactiveVal(NULL)
edit_summary <- shiny::reactiveVal(NULL)
current_selection <- shiny::reactiveVal(NULL)

# New England Optional year selection logic
output$is_new_england <- shiny::reactive({
  if (is.null(state())) return(FALSE)
  
  # New England state FIPS codes
  new_england_fips <- c("09", "23", "25", "33", "44", "50")  # CT, ME, MA, NH, RI, VT
  
  state() %in% new_england_fips
})

# Make it available to the UI
shiny::outputOptions(output, "is_new_england", suspendWhenHidden = FALSE)

# Tract Hunter staged state -----------------------------------------
th_state <- shiny::reactiveVal(NULL)
th_tract_list <- shiny::reactiveVal(NULL)
th_bls_df <- shiny::reactiveVal(NULL)

map_data_dbg <- shiny::reactiveVal(NULL)   # container

highlighted_tracts <- shiny::reactiveVal(character(0))

# Load static data
excel_names <- c("record",
                 "geoid",
                 "st_fips",
                 "cnty_fips",
                 "tract_fips",
                 "name",
                 "tract_pop_dec",
                 "tract_pop_cur",
                 "tract_emp",
                 "tract_unemp",
                 "tract_urate",
                 "tract_urate_error",
                 "cnty_pop_dec",
                 "cnty_pop_cur",
                 "cnty_emp",
                 "cnty_unemp",
                 "cnty_urate",
                 "cnty_urate_error",
                 "pop_shr",
                 "emp_shr",
                 "unemp_shr",
                 "laus_primary",
                 "cnty_emp_ave",
                 "cnty_unemp_ave",
                 "tract_ASU_clf",
                 "tract_ASU_emp",
                 "tract_ASU_unemp",
                 "tract_ASU_urate")
```

# Data Initialization

## Controls {data-width="150"}

This screen allows you to import the BLS-provided ASU file, generally named like *NV_asu23.xlsx* which will be the only external data import step necessary. The script will read the file, extract the state and corresponding year, and standardize the column names to avoid annual updates to the script.

If the necessary data is not in columns **A through AB** within the Excel file, this process will not work correctly.

Once the file is loaded, a preview of the data will appear on the right, the state and year will display below, and the analyst may proceed to the next tab (Load Initial ASU).

Note: at this time, ASUbuildR assumes a state is using county-based census tracts.  If a state uses another geography such as NECTAs as the basis for its ASU tract file, this process will require some modification.

```{r}
shiny::fileInput("file", "Choose Excel File", accept = c(".xls", ".xlsx"))

shiny::textOutput("selected_state")

shiny::textOutput("selected_year")
```

## Output {data-width="850"}

```{r}
shiny::tableOutput("data_preview")

shiny::observeEvent(input$file, {
  shiny::req(input$file)
  df <- readxl::read_excel(input$file$datapath, range = "A2:AB25000", col_names = excel_names) |>
    dplyr::filter(!is.na(geoid)) |>
    dplyr::mutate(GEOID = stringr::str_remove(geoid, "14000US")) |>
    dplyr::select(GEOID,
           st_fips,
           cnty_fips,
           tract_fips,
           name,
           tract_pop_cur,
           tract_ASU_clf,
           tract_ASU_emp,
           tract_ASU_unemp,
           tract_ASU_urate) |> 
    dplyr::mutate(
      tract_pop_cur = as.integer(tract_pop_cur),
      tract_ASU_clf = as.integer(tract_ASU_clf),
      tract_ASU_emp = as.integer(tract_ASU_emp),
      tract_ASU_unemp = as.integer(tract_ASU_unemp)
    )
  
  uploaded_data(df)
  
  uploaded_data() |>
    dplyr::pull(st_fips) |>
    unique() |>
    state()
  
  readxl::read_excel(input$file$datapath, range = "H1:H1", col_names = "year") |>
    dplyr::pull(year) |>
    stringr::str_remove("tract_pop") |>
    tract_year()
  
  output$data_preview <- shiny::renderTable({
    head(uploaded_data(),50)
  })
  
  output$selected_state <- shiny::renderText({
    paste0("Selected FIPS is: ", state())
  })
  
  output$selected_year <- shiny::renderText({
    paste0("Tract Population Year is: ", tract_year())
  })
})
```

# Load Initial ASU

## Controls {data-width="200"}

```{r}
# ---- New England year override controls ------------------------------
shiny::conditionalPanel(
  condition = "output.is_new_england === true",
  shiny::tagList(
    shiny::hr(style = "margin: 0.8rem 0;"),
    shiny::h5("New England Year Selection"),
    shiny::radioButtons(
      inputId = "ne_year_choice",
      label   = "Choose tract year:",
      choices = list(
        "Use detected year (default)" = "detected",
        "Use 2021 (last NECTA year)"  = "2021"
      ),
      selected = "detected",
      inline = FALSE
    ),
    shiny::p(
      style = "font-size: 0.9em; color: #666;",
      "Note: 2021 is the last year NECTA-based tracts were available for New England states."
    )
  )
)

# ---- algorithm picker -------------------------------------------------
shiny::radioButtons(
  inputId = "asu_algo",
  label   = "Choose algorithm",
  choices = c(
    "Tract Hunter"  = "mine",
    "Simple Snake"  = "orig"),
  inline  = TRUE
)

# -----------------------------------------------------------------------
# main "Run" button (always visible)
shiny::div(style = "margin-top: 0.5rem;",
    shiny::actionButton(
      inputId = "process",
      label   = "Load tracts & initialise",
      class   = "btn-primary"
    )
)

# -----------------------------------------------------------------------
# extra Tract-Hunter controls (only when algo == 'mine')
shiny::conditionalPanel(
  condition = "input.asu_algo === 'mine'",
  shiny::tagList(
    shiny::hr(style = "margin: 0.8rem 0;"),
    shiny::div(
      class = "btn-group",           # keep them on one line
      style = "width: 100%;",
      shiny::actionButton("th_pass",    "Run Hunter",     class = "btn-secondary"),
      shiny::actionButton("th_combine", "Combine Groups",   class = "btn-secondary")
    )
  )
)


# ---- dynamic algorithm description -----------------------------------
output$algo_blurb <- shiny::renderUI({

  if (is.null(input$asu_algo) || input$asu_algo == "orig") {
    ## ───────── ORIGINAL METHOD ─────────
    shiny::HTML(
      "<p>
        This button will launch two processes, which will take up to 5&nbsp;minutes
        to complete. For smaller states, it may take under 15&nbsp;seconds.
      </p>
      <p>
        First, the application will download census shapefiles by tract for the
        appropriate state and year. Next, after combining the BLS file with these
        shapefiles, it will iteratively search for contiguous geographic regions
        until the combined unemployment rate in each region is as close to
        6.45 % as possible.
      </p>
      <p>
        When this process is complete, a map will appear to the right, and a
        summary of the created ASU regions will appear below. It is important to
        note these will still include areas that do not qualify as an independent
        ASU (there is no check for population), but it gives the analyst a
        starting place for analysis.
      </p>
      <p>
        Once this step is done, you may proceed to the next step.
      </p>"
    )

  } else {
    ## ───────── TRACT-HUNTER METHOD ─────────
    shiny::HTML(
      "<p><strong>Tract Hunter workflow</strong></p>
       <p>Because Tract Hunter works in stages, the interface exposes those
          stages as separate buttons:</p>
       <ul>
         <li><em>Load tracts & initialise</em><br>
             ▸ downloads shapefiles, merges the BLS file, then runs the
             <strong>Seed + Expand</strong> step automatically. This should only be run once.</li>
         <li><em>Run Hunter</em><br>
             ▸ performs the optimisation/trade pass that adds
             high-unemployment neighbours and drops low-unemployment ones until
             every ASU is as close as possible to the
             <code>6.45%</code> threshold.</li>
         <li><em>Combine Groups</em><br>
             ▸ merges adjacent ASUs that share a boundary. Connected ASUs allow for more tracts to be added, so whenever ASUs are merged it is advisable to run another pass with the Tract Hunter.</li>
       </ul>
       <p>You can stop after any step to inspect the map, or run the buttons
          in sequence for the full, automatic workflow. We suggest iteratively running the Run Hunter and Combine Groups steps until Total Unemployment in ASUs no longer increases.  Each step updates the
          color map to the right and the unemployment totals shown below.</p>"
    )
  }
})

shiny::uiOutput("algo_blurb")

shiny::htmlOutput("total_unemp")

shiny::tableOutput("asu")

shiny::observeEvent(input$process, {
  
  ## 0 · Basic checks ----------------------------------------------------
  shiny::req(uploaded_data(), state(), tract_year())

  # Determine which year to use
  selected_year <- tract_year()  # default to detected year
  
  # Check if this is New England and user selected 2021
  state_val <- state()
  if (!is.null(state_val) && length(state_val) > 0) {
    new_england_fips <- c("09", "23", "25", "33", "44", "50")
    if (state_val %in% new_england_fips && 
        !is.null(input$ne_year_choice) && 
        input$ne_year_choice == "2021") {
      selected_year <- "2021"
    }
  }

  ## 1 · Wrap the whole long job in withProgress -------------------------
  shiny::withProgress(message = "Running ASU initialisation…", value = 0, {
    
    ## 1a · Build tracts + neighbours (can take ~10–60 s the first time)
    shiny::incProgress(0.10, detail = "Downloading Census shapefiles…")
    
    # CHANGE THIS LINE FROM:
    # tract_list <- tigris::tracts(state = state(), year = tract_year()) |>
    # TO:
    tract_list <- tigris::tracts(state = state(), year = selected_year) |>
      dplyr::mutate(
        row_num    = dplyr::row_number(),
        continuous = sfdep::st_contiguity(geometry)
      )

    ## 1b · Merge the BLS data
    shiny::incProgress(0.05, detail = "Merging BLS unemployment data…")
    data_merge <- tract_list |>
      dplyr::left_join(uploaded_data(), by = "GEOID")

    # 2 · Run the chosen ASU algorithm ---------------------------------
    algo_choice <- shiny::isolate(input$asu_algo %||% "orig")
    
    join_flag <- isTRUE(input$join_touching)   # ← keep the flag you already built
    
    shiny::incProgress(0.05, detail = "Finding initial ASU seeds…")
    if (algo_choice == "orig") {
      res <- run_asu_original(tract_list, uploaded_data())
    } else {
      shiny::withProgress(message = "Seeding & expanding…", value = 0, {
        th_tract_list(tract_list)
        th_bls_df(uploaded_data())
        st <- tract_hunter_seed(th_tract_list(), th_bls_df(), verbose = TRUE)})
      th_state(st)
      res <- tract_hunter_finalize(st)
    }

    ## 3 · Finish the bar
    shiny::incProgress(1, detail = "Finishing up…")
  })  # ---- withProgress ends here  -------------------------------------

  ## 4 · Store results & draw map  --------------------------------------
  if (!is.null(res)) {
    full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
    asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
    asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)

    output$asu <- shiny::renderTable( asu_summary(),digits = 3 )

    ## 5. (Re‑)draw the first map ----------------------------------

  output$initial_map <- mapgl::renderMaplibre({

    shiny::req(full_data())
    map_data <- full_data()

    # ---- 6·1 geometry housekeeping ----------------------------------
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)

    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }

    # ---- 6·2 palette / breaks ---------------------------------------
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))

    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)

    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#E0E0E0",
         legend_vals = "(none)",
         legend_cols = "#E0E0E0")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#E0E0E0",
                        stops="#7FC97F",
                        values=1,
                        na_color="#E0E0E0"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#E0E0E0"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}

    pal <- palette_logic(n_asu)

    # ---- 6·3 build map ----------------------------------------------
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.6,
        fill_outline_color = "black",
        tooltip = mapgl::concat(
          "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
          "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"),  "<br>",
          "<strong>UR: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_urate"),
                        style = "decimal", maximum_fraction_digits = 2),
          "%<br>",
          "<strong>Unemp: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_unemp"),
                        style = "decimal", maximum_fraction_digits = 0), "<br>"
        )
      ) |>
      mapgl::add_legend(
        "ASU Number",
        values = pal$legend_vals,
        colors = pal$legend_cols,
        type   = "categorical"
      )
  })

}

})  # ---- end observeEvent -------------------------------------------------

shiny::observeEvent(input$th_pass, {
  shiny::req(th_state())
  shiny::withProgress(message = "Running ASU pass…", value = 0, {
    st <- tract_hunter_asu_pass(th_state(), verbose = TRUE)
  })
  th_state(st)
  res <- tract_hunter_finalize(st)
  full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
  asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
  asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)
  output$asu <- shiny::renderTable( asu_summary(),digits = 3 )
  mapgl::maplibre_proxy("initial_map") |> mapgl::clear_layer("basemap")
  output$initial_map <- mapgl::renderMaplibre({
    shiny::req(full_data())
    map_data <- full_data()
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)
    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))
    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)
    
    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#E0E0E0",
         legend_vals = "(none)",
         legend_cols = "#E0E0E0")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#E0E0E0",
                        stops="#7FC97F",
                        values=1,
                        na_color="#E0E0E0"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#E0E0E0"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}
    
    pal <- palette_logic(n_asu)
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.5,
        fill_outline_color = "black",
        tooltip = mapgl::concat(
          "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
          "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"),  "<br>",
          "<strong>UR: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_urate"),
                        style = "decimal", maximum_fraction_digits = 2),
          "%<br>",
          "<strong>Unemp: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_unemp"),
                        style = "decimal", maximum_fraction_digits = 0), "<br>"
        )
      ) |>
      mapgl::add_legend(
        "ASU Number",
        values = pal$legend_vals,
        colors = pal$legend_cols,
        type   = "categorical"
      )
  })
})

shiny::observeEvent(input$th_combine, {
  shiny::req(th_state())
  shiny::withProgress(message = "Combining ASUs…", value = 0, {
    st <- tract_hunter_combine_groups(th_state())
  })
  th_state(st)
  res <- tract_hunter_finalize(st)
  full_data(res$full_data  )   ; full_data_reset(res$full_data_reset)
  asu_data(res$asu_data    )   ; asu_tracts(res$asu_tracts)
  asu_summary(res$asu_summary) ; map_data_dbg(res$full_data)
  output$asu <- shiny::renderTable( asu_summary(),digits = 3 )
  mapgl::maplibre_proxy("initial_map") |> mapgl::clear_layer("basemap")
  output$initial_map <- mapgl::renderMaplibre({
    shiny::req(full_data())
    map_data <- full_data()
    map_data <- map_data |>
      sf::st_make_valid() |>
      sf::st_zm(what = "ZM", drop = TRUE) |>
      dplyr::filter(!sf::st_is_empty(geometry)) |>
      dplyr::mutate(geom_type = sf::st_geometry_type(geometry)) |>
      dplyr::filter(geom_type %in% c("POLYGON", "MULTIPOLYGON")) |>
      dplyr::select(-geom_type)
    if (nrow(map_data) == 0) {
      return(
        mapgl::maplibre(style = mapgl::carto_style("positron")) |>
        mapgl::add_control("No valid polygon geometry to display.", "top-left")
      )
    }
    map_data <- map_data |>
      dplyr::mutate(asunum = dplyr::na_if(asunum, 0L))
    n_asu <- max(map_data$asunum, na.rm = TRUE)
    n_asu <- ifelse(is.finite(n_asu), n_asu, 0L)
    
    palette_logic <- function(n_asu) {
  if (n_asu == 0) {
    list(fill = "#E0E0E0",
         legend_vals = "(none)",
         legend_cols = "#E0E0E0")

  } else if (n_asu == 1) {
    list(
      fill  = mapgl::step_expr(column="asunum",
                        base="#E0E0E0",
                        stops="#7FC97F",
                        values=1,
                        na_color="#E0E0E0"),
      legend_vals = 1,
      legend_cols = "#7FC97F"
    )

  } else {
    n_cat <- min(max(n_asu, 3L), 8L)          # 3-to-8 distinct hues
    pal   <- RColorBrewer::brewer.pal(n_cat, "Accent")

    # make colours exactly as long as the value vector
    legend_cols <- rep_len(pal, n_asu)

    breaks <- seq(1 + n_asu / n_cat, n_asu, length.out = n_cat - 1)

    list(
      fill = mapgl::step_expr(column   = "asunum",
                       base     = pal[1],
                       stops    = pal[-1],
                       values   = breaks,
                       na_color = "#E0E0E0"),
      legend_vals = seq_len(n_asu),
      legend_cols = legend_cols
    )
  }
}
    
    pal <- palette_logic(n_asu)
    mapgl::maplibre(style = mapgl::carto_style("positron")) |>
      mapgl::fit_bounds(map_data, animate = FALSE) |>
      mapgl::add_fill_layer(
        id                 = "basemap",
        source             = map_data,
        fill_color         = pal$fill,
        fill_opacity       = 0.5,
        fill_outline_color = "black",
        tooltip = mapgl::concat(
          "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
          "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"),  "<br>",
          "<strong>UR: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_urate"),
                        style = "decimal", maximum_fraction_digits = 2),
          "%<br>",
          "<strong>Unemp: </strong>",
          mapgl::number_format(mapgl::get_column("tract_ASU_unemp"),
                        style = "decimal", maximum_fraction_digits = 0), "<br>"
        )
      ) |>
      mapgl::add_legend(
        "ASU Number",
        values = pal$legend_vals,
        colors = pal$legend_cols,
        type   = "categorical"
      )
  })
})

#-------Total Unemployment Box --------------------------------
total_unemp <- shiny::reactive({
  shiny::req(full_data())                                  # wait until available
  full_data() |>
    dplyr::filter(asunum > 0) |>
    dplyr::summarise(unemp = sum(tract_ASU_unemp, na.rm = TRUE)) |>
    dplyr::pull(unemp)
})

output$total_unemp <- shiny::renderUI({
  shiny::HTML(
    paste0("<strong>Total Unemployment in ASUs:</strong> ",
           scales::comma(total_unemp()))
  )
})

output$total_unemp2 <- shiny::renderUI({
  shiny::HTML(
    paste0("<strong>Total Unemployment in ASUs:</strong> ",
           scales::comma(total_unemp()))
  )
})
```

## Output {data-width="800"}

```{r}
mapgl::maplibreOutput("initial_map", height = "100vh")
```

# Modify ASU Selections

## Controls {data-width="150" style="height: 100vh; overflow-y: auto; padding-right: 10px;"}

These tools allow you to select, inspect, and change ASU designations for individual Census tracts.  *Selected* Census tracts will be outlined in red, and are the tracts updated when you change the ASU number.  You may also click on the map to select or unselect individual tracts. An ASU value of 0 means the tract is not included in any ASU.

```{r}
#-------Total Unemployment Box --------------------------------
shiny::htmlOutput("total_unemp2")
shiny::renderUI(shiny::HTML("<hr>"))

# Select an ASU
asu_selection_ui <- shiny::reactive({
  shiny::selectInput("select_asunum", "Select ASU Number:",
              choices = c("None", asu_choices()),
              selected = "None")
})
shiny::renderUI(asu_selection_ui())
shiny::renderUI(shiny::HTML("<hr>"))

# Change ASU
shiny::numericInput("new_asu", "Change ASU Value:", value = 0, min = 0)
shiny::actionButton("update", "Update Selected Tracts")
shiny::renderUI(shiny::HTML("<hr>"))

# Clear Selected Tracts
shiny::actionButton("clear", "Clear Selected Tracts")
shiny::renderUI(shiny::HTML("<hr>"))

# Show Data for Selection
shiny::actionButton("preview", "Show Data for Selected Tracts")
asu_choices <- shiny::reactive({
  shiny::req(full_data())                     # only run after full_data exists
  full_data() |> dplyr::pull(asunum) |> unique() |> sort()
})

shiny::renderUI(shiny::HTML("<hr>"))

# Show Lowest UR Tracts in Selection
shiny::selectInput("unemployment_filter", 
             "Highlight selected tracts with:",
             choices = list("Low unemployment" = "low", 
                           "High unemployment" = "high"),
             selected = "low")
shiny::numericInput("percentile", "Percentile Threshold:", value = 5, min = 1, max = 100, step = 1)
shiny::actionButton("filter_percentile", "Highlight Tracts")
shiny::actionButton("clear_percentile", "Clear Highlights")
shiny::renderUI(shiny::HTML("<hr>"))

# Single GROID Selection
shiny::textInput("manual_geoid", "Enter a GEOID:", placeholder = "32031990000")
shiny::actionButton("select_geoid", "Select a Single Tract")
shiny::renderUI(shiny::HTML("<hr>"))

# Reset to Initial Load
shiny::actionButton("reset", "Reset to Initial Data")
```

## Interactive Map {data-width="600"}

```{r}
# The map
  mapgl::maplibreOutput("edit_map", height = "100vh")
  
output$edit_map <- mapgl::renderMaplibre({
  
  shiny::req(full_data())
  
  number_asus <- max(full_data()$asunum)
  number_categories <- min(c(number_asus, 8))
  asu_per_category <- number_asus/number_categories
  
  # Create breaks for ASU categories, excluding 0
  if (number_categories == 1) {
    asu_breaks <- 1
    actual_categories <- 1
    brewer_pal <- "#7FC97F"
  } else {
    asu_breaks <- seq(from = 1, to = number_asus, length.out = number_categories)
    actual_categories <- max(3, number_categories)
    full_brewer_pal <- RColorBrewer::brewer.pal(actual_categories, "Accent")
    brewer_pal <- full_brewer_pal[1:number_categories]
  }

  mapgl::maplibre(style = mapgl::carto_style("positron")) |>
    mapgl::fit_bounds(full_data(), animate = FALSE) |> 
    mapgl::add_fill_layer(
      id = "basemap",
      source = full_data(),
      fill_color = mapgl::step_expr(
        column = "asunum",
        base = "#E0E0E0",
        stops = brewer_pal,
        values = asu_breaks,
        na_color = "#E0E0E0"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      tooltip = mapgl::concat(
        "<strong>ASU Number: </strong>",mapgl::get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>",mapgl::get_column("GEOID"),"<br>",
        "<strong>Tract Population: </strong>",mapgl::number_format(mapgl::get_column("tract_pop_cur"), style = "decimal", maximum_fraction_digits = 0),"<br>",
        "<strong>Tract Labor Force: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_clf"), style = "decimal", maximum_fraction_digits = 0),"<br>",
        "<strong>Tract Unemployment Rate: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2),"%<br>",
        "<strong>Tract Unemployment: </strong>",mapgl::number_format(mapgl::get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0),"<br>")
    ) |>
    # Pre-add empty layers for selection and highlighting - avoids repeated add/clear cycles
    mapgl::add_line_layer(
      id = "selected",
      source = full_data(),
      line_color = "red",
      line_width = 2,
      line_opacity = 1,
      filter = list("==", c("get", "GEOID"), "__NONE__")  # Initially hide all features
    ) |>
    mapgl::add_fill_layer(
      id = "highlighted",
      source = full_data(),
      fill_color = "black",
      fill_opacity = 0.8,
      filter = list("==", c("get", "GEOID"), "__NONE__")  # Initially hide all features
    )
})

# OPTIMIZATION 1: Use set_filter instead of clear/add for selection highlighting
shiny::observeEvent(input$edit_map_feature_click, {
  click <- input$edit_map_feature_click
  current_selection <- selected_tracts()
  
  clicked_geoid <- click$properties$GEOID
  
  if (is.null(clicked_geoid) || length(clicked_geoid) == 0 || is.na(clicked_geoid)) {
    return()
  }
  
  # Add or remove the selected tract
  if (clicked_geoid %in% current_selection) {
    current_selection <- setdiff(current_selection, clicked_geoid)
  } else {
    current_selection <- c(current_selection, clicked_geoid)
  }
  
  selected_tracts(current_selection)
  
  # OPTIMIZATION: Use set_filter instead of clear_layer + add_line_layer
  if (length(current_selection) > 0 && !any(is.na(current_selection))) {
    # Create filter expression for selected tracts
    if (length(current_selection) == 1) {
      filter_expr <- list("==", c("get", "GEOID"), as.character(current_selection[1]))
    } else {
      # For multiple values, use "any" with "in" operator
      filter_expr <- list("in", c("get", "GEOID"), list("literal", as.character(current_selection)))
    }
    
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("selected", filter_expr)
  } else {
    # Hide all features in selection layer
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__"))
  }
  
  # Update the selection table
  output$selection_table <- shiny::renderTable({
    selected_tracts()
  }, digits = 3)
})

# OPTIMIZATION 2: Debounce rapid interactions
clear_selection_debounced <- shiny::debounce(shiny::reactive({
  input$clear
}), 100)

shiny::observeEvent(clear_selection_debounced(), {
  selected_tracts(NULL)
  
  # Use set_filter to hide selection
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__"))
  
  # Reset ASU dropdown to "None"
    shiny::updateSelectInput(session, "select_asunum", selected = "None")
})

# OPTIMIZATION 3: Efficient ASU selection with set_filter
shiny::observeEvent(input$select_asunum, {
  shiny::req(full_data())
  
  if (input$select_asunum == "None") {
    selected_tracts(NULL)
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__"))
    return()
  }
  
  # Get all tracts with the selected ASU number
  selected_tract_ids <- full_data() |>
    dplyr::filter(asunum == as.numeric(input$select_asunum)) |>
    dplyr::pull(GEOID)
  
  # Ensure we have valid tract IDs
  if (length(selected_tract_ids) == 0) {
    selected_tracts(NULL)
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__"))
    return()
  }
  
  selected_tracts(selected_tract_ids)
  
  # Use set_filter for performance
  if (length(selected_tract_ids) == 1) {
    filter_expr <- list("==", c("get", "GEOID"), as.character(selected_tract_ids[1]))
  } else {
    filter_expr <- list("in", c("get", "GEOID"), list("literal", as.character(selected_tract_ids)))
  }
  
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::set_filter("selected", filter_expr) |>
    mapgl::fit_bounds(subset(full_data(), GEOID %in% selected_tract_ids), animate = TRUE)
})

# Manual GEOID selection with set_filter
shiny::observeEvent(input$select_geoid, {
  shiny::req(full_data())
  
  selected_tract <- full_data() |>
    dplyr::filter(GEOID == input$manual_geoid)
  
  if (nrow(selected_tract) > 0) {
    # Reset ASU dropdown to "None" FIRST
    shiny::updateSelectInput(session, "select_asunum", selected = "None")
    
    # THEN update the map and selection
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("selected", list("==", c("get", "GEOID"), as.character(input$manual_geoid))) |>
      mapgl::fit_bounds(selected_tract, animate = TRUE)
    
    selected_tracts(selected_tract$GEOID)
  }
})

# OPTIMIZATION 4: Memoize expensive calculations
filtered_tracts_memo <- shiny::reactive({
  shiny::req(input$percentile, input$unemployment_filter, full_data(), selected_tracts())
  
  # Use a cache key for memoization
  cache_key <- paste(
    paste(selected_tracts(), collapse = ","),
    input$percentile,
    input$unemployment_filter,
    sep = "_"
  )
  
  potential_highlights <- full_data() |>
    dplyr::filter(GEOID %in% selected_tracts(),
           tract_pop_cur > 0, tract_ASU_clf > 0)

  
if (input$unemployment_filter == "low") {
  
  # Remove tracts where tract_ASU_clf is 0

  # Calculate dynamic threshold from eligible tracts
  threshold <- stats::quantile(potential_highlights$tract_ASU_urate, input$percentile / 100)
  
  filtered_selected <- potential_highlights |>
    dplyr::filter(tract_ASU_urate <= threshold) |>
    dplyr::pull(GEOID)
  
} else {

  threshold <- stats::quantile(potential_highlights$tract_ASU_urate, 1 - (input$percentile / 100))
  
  filtered_selected <- potential_highlights |>
    dplyr::filter(tract_ASU_urate >= threshold) |>
    dplyr::pull(GEOID)
}
  
  return(filtered_selected)
}) |> 
  # Add memoization with cache invalidation
  shiny::bindCache(input$percentile, input$unemployment_filter, selected_tracts(), full_data())

# OPTIMIZATION 5: Debounced filtering with set_filter
filter_debounced <- shiny::debounce(shiny::reactive({
  list(input$filter_percentile, input$unemployment_filter)
}), 250)  # 250ms delay

# In your existing filter_debounced observer, add this line:
shiny::observeEvent(filter_debounced(), {
  filtered_selected <- filtered_tracts_memo()
  highlighted_tracts(filtered_selected)
  
  # Clear DT table selections when using percentile filtering
  DT::dataTableProxy("summary_table") |> DT::clearSearch()
  
  # Use set_filter instead of clear + add
  if (length(filtered_selected) > 0 && !any(is.na(filtered_selected))) {
    if (length(filtered_selected) == 1) {
      filter_expr <- list("==", c("get", "GEOID"), as.character(filtered_selected[1]))
    } else {
      filter_expr <- list("in", c("get", "GEOID"), list("literal", as.character(filtered_selected)))
    }
    
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("highlighted", filter_expr)
  } else {
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("highlighted", list("==", c("get", "GEOID"), "__NONE__"))
  }
})

# Clear highlights with set_filter
shiny::observeEvent(list(input$clear_percentile, input$select_asunum), {
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::set_filter("highlighted", list("==", c("get", "GEOID"), "__NONE__"))
})

# Helper function to calculate color scheme
calculate_color_scheme <- function(data) {
  number_asus <- max(data$asunum, na.rm = TRUE)
  number_categories <- min(c(number_asus, 8))
  
  if (number_categories == 1) {
    asu_breaks <- 1
    actual_categories <- 1
    brewer_pal <- "#7FC97F"
  } else {
    asu_breaks <- seq(from = 1, to = number_asus, length.out = number_categories)
    actual_categories <- max(3, number_categories)
    full_brewer_pal <- RColorBrewer::brewer.pal(actual_categories, "Accent")
    brewer_pal <- full_brewer_pal[1:number_categories]
  }
  
  return(list(breaks = asu_breaks, colors = brewer_pal))
}


# OPTIMIZATION 1: Pre-calculate and cache color schemes
color_schemes_cache <- shiny::reactiveValues()

calculate_color_scheme_cached <- function(max_asu) {
  cache_key <- as.character(max_asu)
  
  if (!exists(cache_key, envir = color_schemes_cache)) {
    number_categories <- min(c(max_asu, 8))
    
    if (number_categories <= 1) {
      scheme <- list(breaks = 1, colors = "#7FC97F")
    } else {
      asu_breaks <- seq(from = 1, to = max_asu, length.out = number_categories)
      actual_categories <- max(3, number_categories)
      full_brewer_pal <- RColorBrewer::brewer.pal(actual_categories, "Accent")
      brewer_pal <- full_brewer_pal[1:number_categories]
      scheme <- list(breaks = asu_breaks, colors = brewer_pal)
    }
    
    color_schemes_cache[[cache_key]] <- scheme
  }
  
  return(color_schemes_cache[[cache_key]])
}

# Update with dynamic color changes
shiny::observeEvent(input$update, {
  shiny::req(selected_tracts(), full_data())
  
  # Store current data and new ASU value
  current_data <- full_data()
  new_asu <- as.numeric(input$new_asu)
  selected_ids <- selected_tracts()
  
  # CRITICAL: Isolate this heavy computation from reactive context
  shiny::isolate({
    # Batch update - more efficient than row-by-row
    updated_data <- current_data |>
      dplyr::mutate(
        asunum = ifelse(GEOID %in% selected_ids, new_asu, asunum)
      )
    
    # Update data ONCE
    full_data(updated_data)
  })
  
  # Only update colors if the maximum ASU changed
  old_max <- max(current_data$asunum, na.rm = TRUE)
  new_max <- max(updated_data$asunum, na.rm = TRUE)
  
  if (old_max != new_max) {
    # Use cached color scheme calculation
    color_scheme <- calculate_color_scheme_cached(new_max)
    
    new_color_expr <- mapgl::step_expr(
      column = "asunum",
      base = "#E0E0E0",
      stops = color_scheme$colors,
      values = color_scheme$breaks,
      na_color = "#E0E0E0"
    )
    
    # Update colors without full re-render
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_paint_property("basemap", "fill-color", new_color_expr)
  } else {
    # If max ASU didn't change, just trigger a paint refresh
    # This is much faster than updating the entire color expression
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_paint_property("basemap", "fill-opacity", 0.5)
  }
  
  # Clear selection efficiently
  selected_tracts(NULL)
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__"))
})

# Reset with optimized clearing and color updates
shiny::observeEvent(input$reset, {
  shiny::req(full_data_reset(), full_data())
  
  old_data <- full_data()
  reset_data <- full_data_reset()
  full_data(reset_data)
  
  # Trigger map re-render for reset
  initial_map_data(reset_data)
  
  selected_tracts(NULL)
  
  # Clear both layers efficiently
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::set_filter("selected", list("==", c("get", "GEOID"), "__NONE__")) |>
    mapgl::set_filter("highlighted", list("==", c("get", "GEOID"), "__NONE__"))
})

# OPTIMIZATION 8: Optimized data loading observer
# Observer for loading the data
shiny::observeEvent(input$load_data, {
  shiny::req(input$load_data)
  
  # Read the RDS file into a data frame
  loaded_data <- tryCatch({
    readRDS(input$load_data$datapath)
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Loading Data",
      "Failed to load the data. Please check the file format.",
      easyClose = TRUE
    ))
    return(NULL)
  })
  
  # If loaded_data is NULL (failed to load), exit the observer
  shiny::req(!is.null(loaded_data))
  
  # Ensure the loaded data is an sf object
  if (!inherits(loaded_data, "sf")) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Loading Data",
      "The loaded data is not a valid sf object.",
      easyClose = TRUE
    ))
    return(NULL)
  }
  
  # Update full_data with the loaded data
  full_data(loaded_data)
  
  # Trigger map re-render with new data
  initial_map_data(loaded_data)
  
  # Provide feedback to the user
  shiny::showModal(shiny::modalDialog(
    title = "Data Loaded",
    "Your data has been successfully loaded.",
    easyClose = TRUE
  ))
  
  # Calculate new color scheme using helper function
  color_scheme <- calculate_color_scheme(loaded_data)
  
  # OPTIMIZATION: For data loading, we need to recreate layers but preserve zoom
  # Store current map state if possible
  current_zoom <- NULL  # Would need to get from map state if available
  current_center <- NULL
  
  # Update the map layers (necessary when loading completely new data)
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::clear_layer("basemap") |>
    mapgl::clear_layer("highlighted") |>
    mapgl::clear_layer("selected") |>
    mapgl::add_fill_layer(
      id = "basemap",
      source = loaded_data,
      fill_color = mapgl::step_expr(
        column = "asunum",
        base = "#E0E0E0",
        stops = color_scheme$colors,
        values = color_scheme$breaks,
        na_color = "#E0E0E0"
      ),
      fill_opacity = 0.5,
      fill_outline_color = "black",
      tooltip = mapgl::concat(
        "<strong>ASU Number: </strong>", mapgl::get_column("asunum"), "<br>",
        "<strong>Tract GEOID: </strong>", mapgl::get_column("GEOID"), "<br>",
        "<strong>Tract Population: </strong>", mapgl::number_format(mapgl::get_column("tract_pop_cur"), style = "decimal", maximum_fraction_digits = 0), "<br>",
        "<strong>Tract Labor Force: </strong>", mapgl::number_format(mapgl::get_column("tract_ASU_clf"), style = "decimal", maximum_fraction_digits = 0), "<br>",
        "<strong>Tract Unemployment Rate: </strong>", mapgl::number_format(mapgl::get_column("tract_ASU_urate"), style = "decimal", maximum_fraction_digits = 2), "%<br>",
        "<strong>Tract Unemployment: </strong>", mapgl::number_format(mapgl::get_column("tract_ASU_unemp"), style = "decimal", maximum_fraction_digits = 0), "<br>"
      )
    ) |>
    mapgl::add_line_layer(
      id = "selected",
      source = loaded_data,
      line_color = "red",
      line_width = 3,
      line_opacity = 1,
      filter = list("==", c("get", "GEOID"), "__NONE__")
    ) |>
    mapgl::add_fill_layer(
      id = "highlighted",
      source = loaded_data,
      fill_color = "black",
      fill_opacity = 0.8,
      filter = list("==", c("get", "GEOID"), "__NONE__")
    ) |>
    mapgl::fit_bounds(loaded_data, animate = TRUE)
  
  # Clear any existing selections/highlights
  selected_tracts(NULL)
  highlighted_tracts(NULL)
})

# OPTIMIZATION 7: Enhanced cleanup with requestAnimationFrame equivalent
shiny::observe({
  shiny::invalidateLater(60000)
  if (exists("gc")) gc()
}) |> 
shiny::bindEvent(input$update, ignoreInit = TRUE)

# Trigger map resize when panels are resized
shiny::observeEvent(input$map_resize, {
  # Force map to resize/redraw
  mapgl::maplibre_proxy("edit_map") |>
    mapgl::maplibre_resize()
}, ignoreInit = TRUE)
```

## Selection Summary {data-width="250"}

```{r}
# Your existing preview_data reactive (keep this as-is)
preview_data <- shiny::reactive({
  shiny::req(selected_tracts())
  replacement_data <- full_data() |>
    sf::st_drop_geometry() |>
    subset(GEOID %in% selected_tracts())
  summary_data <- replacement_data |>
    dplyr::ungroup() |>
    dplyr::summarize(
      tracts = dplyr::n(),
      population = sum(tract_pop_cur, na.rm = TRUE),
      lf = sum(tract_ASU_clf, na.rm = TRUE),
      unemp = sum(tract_ASU_unemp, na.rm = TRUE),
      ur = round(unemp/lf*100, 5)
    )
  
  list(data = replacement_data, summary = summary_data)
}) |>
  shiny::bindCache(selected_tracts(), full_data())

# Update the preview button observer to handle existing logic
shiny::observeEvent(input$preview, {
  if (length(selected_tracts()) > 0) {
    # Your existing preview logic
    preview_result <- preview_data()
    edit_table(preview_result$data)
    edit_summary(preview_result$summary)
    output$selection_summary <- shiny::renderTable({
      edit_summary()
    })
  } else {
    shiny::showNotification("No tracts selected", type = "warning")
  }
})

# Conditional display based on selection
shiny::conditionalPanel(
  condition = "output.has_selection == true",
  style = "height: calc(100vh - 20px); display: flex; flex-direction: column;",
  
  shiny::h3(" Summary of Selected Tracts"),
  shiny::hr(),
  
  # Summary statistics
  shiny::div(
    style = "background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; flex-shrink: 0;",
    shiny::textOutput("summary_count"),
    shiny::br(),
    shiny::textOutput("summary_total_pop"),
    shiny::textOutput("summary_total_labor_force"),
    shiny::textOutput("summary_avg_unemployment_rate"),
    shiny::textOutput("summary_total_unemployment")
  ),
  
  shiny::hr(style = "flex-shrink: 0;"),
  
  # Detailed table
  shiny::h4("Tract Details", style = "flex-shrink: 0;"),
  shiny::div(
    style = "flex: 1; overflow: hidden; border: 1px solid #dee2e6; border-radius: 5px; min-height: 200px;",
    DT::dataTableOutput("summary_table", width = "100%", height = "100%")
  )
)

# No selection message
shiny::conditionalPanel(
  condition = "output.has_selection == false",
  shiny::div(
    style = "text-align: center; color: #6c757d; font-style: italic; padding: 50px 20px;",
    shiny::h4("No tracts currently selected"),
    shiny::p("Select tracts on the map or use the controls to view summary data here.")
  )
)

# Server logic for conditional display
output$has_selection <- shiny::reactive({
  length(selected_tracts()) > 0
})
shiny::outputOptions(output, "has_selection", suspendWhenHidden = FALSE)

# Summary statistics outputs using your existing preview_data reactive
output$summary_count <- shiny::renderText({
  shiny::req(selected_tracts())
  preview_result <- preview_data()
  paste("Number of selected tracts:", preview_result$summary$tracts)
})

output$summary_total_pop <- shiny::renderText({
  shiny::req(selected_tracts())
  preview_result <- preview_data()
  paste("Total population:", format(preview_result$summary$population, big.mark = ","))
})

output$summary_total_labor_force <- shiny::renderText({
  shiny::req(selected_tracts())
  preview_result <- preview_data()
  paste("Total labor force:", format(preview_result$summary$lf, big.mark = ","))
})

output$summary_avg_unemployment_rate <- shiny::renderText({
  shiny::req(selected_tracts())
  preview_result <- preview_data()
  paste("Average unemployment rate:", preview_result$summary$ur, "%")
})

output$summary_total_unemployment <- shiny::renderText({
  shiny::req(selected_tracts())
  preview_result <- preview_data()
  paste("Total unemployment:", format(preview_result$summary$unemp, big.mark = ","))
})

# Detailed table output using your existing preview_data reactive
# Server side - replace renderTable with renderDataTable
output$summary_table <- DT::renderDataTable({
  shiny::req(selected_tracts())
  
  preview_result <- preview_data()
  selected_data <- preview_result$data |>
    dplyr::select(GEOID, asunum, tract_pop_cur, tract_ASU_clf, 
           tract_ASU_urate, tract_ASU_unemp) |>
    dplyr::arrange(GEOID)
  
  # Format the data for display
  selected_data |>
    dplyr::mutate(
      tract_pop_cur = format(tract_pop_cur, big.mark = ","),
      tract_ASU_clf = format(tract_ASU_clf, big.mark = ","),
      tract_ASU_urate = round(tract_ASU_urate, 2),
      tract_ASU_unemp = format(tract_ASU_unemp, big.mark = ",")
    ) |>
    dplyr::rename(
      "GEOID" = GEOID,
      "ASU" = asunum,
      "Population" = tract_pop_cur,
      "Labor Force" = tract_ASU_clf,
      "Unemp. Rate %" = tract_ASU_urate,
      "Unemp." = tract_ASU_unemp
    )
}, options = list(
  pageLength = -1,
  dom = 't',
  ordering = TRUE,
  class = 'stripe hover',
  columnDefs = list(list(className = 'dt-center', targets = '_all')),
  selection = list(mode = 'multiple', target = 'row')  # Enable row selection
))

# Observer to handle DT table row selections for map highlighting
shiny::observeEvent(input$summary_table_rows_selected, {
  shiny::req(selected_tracts())
  
  if (is.null(input$summary_table_rows_selected) || length(input$summary_table_rows_selected) == 0) {
    # No rows selected in table - clear highlights
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("highlighted", list("==", c("get", "GEOID"), "__NONE__"))
    return()
  }
  
  # Get the GEOIDs corresponding to the selected rows in the table
  preview_result <- preview_data()
  table_data <- preview_result$data |>
    dplyr::select(GEOID, asunum, tract_pop_cur, tract_ASU_clf, 
           tract_ASU_urate, tract_ASU_unemp) |>
    dplyr::arrange(GEOID)
  
  # Get GEOIDs for selected rows
  selected_row_indices <- input$summary_table_rows_selected
  highlighted_geoids <- table_data$GEOID[selected_row_indices]
  
  # Update map highlighting using the existing highlighted layer
  if (length(highlighted_geoids) > 0 && !any(is.na(highlighted_geoids))) {
    if (length(highlighted_geoids) == 1) {
      filter_expr <- list("==", c("get", "GEOID"), as.character(highlighted_geoids[1]))
    } else {
      filter_expr <- list("in", c("get", "GEOID"), list("literal", as.character(highlighted_geoids)))
    }
    
    mapgl::maplibre_proxy("edit_map") |>
      mapgl::set_filter("highlighted", filter_expr)
  }
})

```

# Save and Load Data

## Controls {data-width="150"}

These buttons allow you to save the map in progress so that you can load
it again in the future to continue your work.

First, choose a save directory. The default is your current working
directory. After loading data, you can go directly to the ASU
Modification tab to continue making edits.

```{r}
# Directory selection - Simple text input approach
shiny::textInput("save_dir_path", "Save Directory Path:", value = getwd(), width = "100%")
#shiny::actionButton("browse_dir", "Browse for Directory") # non-functional
shiny::textOutput("current_save_dir")
shiny::textOutput("dir_status")
shiny::br()

shiny::actionButton("save_data", "Save Data")
shiny::fileInput("load_data", "Load Data", accept = c(".rds"))

# Reactive value to store the selected directory
save_directory <- shiny::reactiveVal(getwd())  # Default to current working directory

# Observer to handle directory path changes
shiny::observeEvent(input$save_dir_path, {
  if (!is.null(input$save_dir_path) && input$save_dir_path != "") {
    if (dir.exists(input$save_dir_path)) {
      save_directory(input$save_dir_path)
    }
  }
})

# Display current save directory
output$current_save_dir <- shiny::renderText({
  paste("Current save directory: ", save_directory())
})

# Display directory status
output$dir_status <- shiny::renderText({
  if (dir.exists(save_directory())) {
    "✓ Directory exists and is accessible"
  } else {
    "⚠ Directory does not exist - it will be created when saving"
  }
})

# Observer for saving the data
shiny::observeEvent(input$save_data, {
  shiny::req(full_data())
  
  # Use the selected directory
  save_path <- file.path(save_directory(), "saved_data.rds")
  
  # Check if directory exists, create if it doesn't
  if (!dir.exists(save_directory())) {
    dir.create(save_directory(), recursive = TRUE)
  }
  
  # Save the full_data object to an RDS file
  tryCatch({
    saveRDS(full_data(), save_path)
    
    # Provide feedback to the user
    shiny::showModal(shiny::modalDialog(
      title = "Data Saved",
      paste("Your data has been saved to:", save_path),
      easyClose = TRUE
    ))
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Saving Data",
      paste("Failed to save data:", e$message),
      easyClose = TRUE
    ))
  })
})


```

## Output {data-width="850"}

```{r}
# Empty output section
```

# ASU Review and Finalization

## Controls {data-width="150"}

This screen will allow you to review your selected ASUs. It uses a
threshold of 6.45% unemployment and a population of 10,000, but these
numbers can be modified in case they change in the future.

*Generate ASU Summary* will show a table of all ASUs, and whether they
pass or fail the ASU definitions for unemployment and population. Please
pay attention to these measures - an unemployment rate of 6.449% will
display as 6.45%, but will fail the validation.

Note, you *may* go back and forth between the selection and review
screens.

When ready to create an output file, the *Generate LSS .txt File* button
will create a formatted batch file for upload to LSS.

```{r}
shiny::numericInput("asu_ur", "ASU Unemployment Rate Threshold:", value = 6.45, min = 0)

shiny::numericInput("asu_pop", "ASU Population Threshold:", value = 10000, min = 0)

shiny::actionButton("run_asu_summary", "Generate ASU Summary")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::textOutput("current_save_dir")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::actionButton("lss_txt", "Generate LSS .txt File")
shiny::renderUI(shiny::HTML("<hr>"))

shiny::actionButton("review_txt", "Create Summary CSV")
```

## Output {data-width="850"}

```{r}
shiny::tableOutput("asu_review")

summarized_asu <- shiny::reactiveVal(NULL)

shiny::observeEvent(input$run_asu_summary, {
  
  shiny::req(full_data())
  
  summary_table <- full_data() |>
    sf::st_drop_geometry() |>
    dplyr::group_by(asunum) |>
    dplyr::filter(asunum > 0.5) |>
    dplyr::summarize(
      Tracts = dplyr::n(),
      Population = sum(tract_pop_cur, na.rm = TRUE),
      `Labor Force` = sum(tract_ASU_clf, na.rm = TRUE),
      Unemployment = sum(tract_ASU_unemp, na.rm = TRUE),
      `Unemployment Rate` = round(Unemployment/`Labor Force`*100, 5)
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(
      ur_qualified = dplyr::if_else(`Unemployment Rate` >= input$asu_ur, TRUE, FALSE),
      pop_qualified = dplyr::if_else(Population >= input$asu_pop, TRUE, FALSE),
      asu_qualified = ur_qualified & pop_qualified
    )
  
  summarized_asu(summary_table)
})

output$asu_review <- shiny::renderTable({
  summarized_asu()
})

shiny::observeEvent(input$lss_txt, {
  
  shiny::req(full_data())

  # Function to generate text content
  generate_txt <- function() {
    df <- full_data() |>
      sf::st_drop_geometry() |>
      dplyr::select(GEOID, asunum) |>
      dplyr::filter(asunum > 0) |>
      dplyr::mutate(asunum = as.integer(asunum),
             GEOID = paste0("14000US", GEOID),
             asunum = paste0("SU", state(), sprintf("%04d", asunum)),
             GEOID = paste(asunum, GEOID, sep = " + ")) |> 
      dplyr::arrange(asunum, GEOID) |>
      dplyr::select(-asunum)

    txt_content <- utils::capture.output(utils::write.table(df, quote=FALSE, row.names=FALSE, col.names = FALSE))
    txt_content <- paste(txt_content, collapse="\n")
    return(txt_content)
  }

  # Get the current save directory from the reactive value
  current_dir <- save_directory()
  
  # Validate directory path
  if (is.null(current_dir) || current_dir == "") {
    shiny::showModal(shiny::modalDialog(
      title = "No Directory Selected",
      "Please select a save directory first in the Save and Load Data tab.",
      easyClose = TRUE
    ))
    return()
  }

  # Create the content
  txt_content <- generate_txt()

  # Use the selected save directory
  filePath <- file.path(current_dir, "lss_batch_file.txt")
  
  # Ensure directory exists
  if (!dir.exists(current_dir)) {
    tryCatch({
      dir.create(current_dir, recursive = TRUE)
    }, error = function(e) {
      shiny::showModal(shiny::modalDialog(
        title = "Directory Error",
        paste("Cannot create directory:", current_dir, "\nError:", e$message),
        easyClose = TRUE
      ))
      return()
    })
  }
  
  tryCatch({
    # Write the file
    writeLines(txt_content, filePath)
    
    # Show success message with file location
    shiny::showModal(shiny::modalDialog(
      title = "File Created Successfully",
      shiny::HTML(paste0(
        "<strong>LSS batch file has been saved to:</strong><br>",
        "<code>", filePath, "</code>"
      )),
      easyClose = TRUE
    ))
    
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Creating File",
      paste("Failed to create LSS file:", e$message),
      easyClose = TRUE
    ))
  })
})

shiny::observeEvent(input$review_txt, {

  shiny::req(full_data())

  # Function to generate CSV content
  generate_csv <- function() {
    df <- full_data() |>
      sf::st_drop_geometry() |>
      dplyr::arrange(asunum, GEOID)
    
    return(df)
  }
  
  # Get the current save directory from the reactive value
  current_dir <- save_directory()
  
  # Validate directory path
  if (is.null(current_dir) || current_dir == "") {
    shiny::showModal(shiny::modalDialog(
      title = "No Directory Selected",
      "Please select a save directory first in the Save and Load Data tab.",
      easyClose = TRUE
    ))
    return()
  }

  # Create the content
  df <- generate_csv()

  # Use the selected save directory
  filePath <- file.path(current_dir, "ASU_Review_File.csv")
  
  # Ensure directory exists
  if (!dir.exists(current_dir)) {
    tryCatch({
      dir.create(current_dir, recursive = TRUE)
    }, error = function(e) {
      shiny::showModal(shiny::modalDialog(
        title = "Directory Error",
        paste("Cannot create directory:", current_dir, "\nError:", e$message),
        easyClose = TRUE
      ))
      return()
    })
  }
  
  tryCatch({
    # Write the CSV file
    utils::write.csv(df, filePath, row.names = FALSE)
    
    # Show success message with file location
    shiny::showModal(shiny::modalDialog(
      title = "File Created Successfully",
      shiny::HTML(paste0(
        "<strong>ASU Review CSV has been saved to:</strong><br>",
        "<code>", filePath, "</code>"
      )),
      easyClose = TRUE
    ))
    
  }, error = function(e) {
    shiny::showModal(shiny::modalDialog(
      title = "Error Creating File",
      paste("Failed to create CSV file:", e$message),
      easyClose = TRUE
    ))
  })
})

####################
## Future Development

# Export Excel Worksheet with tract details and selections.
# Allow "Save" of data with txt/Excel files so single session is not required.
# Better table formatting.
# highlight high unemployment tracts in non-included areas.
# Check for contiguity of selected ASUs after manual edits.
# Export high-resolution images of ASUs for review.
# Use reactlog package to monitor reactive interactions in the code for cleanup. https://mastering-shiny.org/reactive-graph.html
```


# How to Use ASUbuildR

**About ASUloadR**

ASUloadR is an application built in R using Shiny and Flexdashboard to
create a point-and-click environment to build Areas of Substantial
Unemployment (ASU). While this package does not replace the work of an
analyst in a state from working on the ASU process, it provides tools to
make that process more straightforward. It should be noted, the U.S. Bureau of Labor Statistics has several
options for designating ASUs. **ASUloadR** only uses the addition
method, building regions at the Census Tract level. Analysts may
discover that other alternatives work better for their state in a given
year.

The ASU creation logic in this program was created by a collaboration
between the states of Ohio and Nevada, with the Shiny app and Graphical
User Interface designed by Nevada’s Research & Analysis Bureau. The Github repository for this package can be found at <https://github.com/schmidtDETR/ASUbuildR>

**About the ASU Process**

The ASU process typically begins when the U.S. Bureau of Labor
Statistics distributes to each state a file providing the calculated
inputs for regions within the state from which ASUs must be designated.
This is provided as an Excel sheet with a filename like `ST_asuYY.xlsx`
where ST is the state abbreviation and YY is the year for which the ASU
is being designated. **ASUloadR** is currently designed to pull
information directly from this file, including identifying the state and
year for which data should be retrieved. Because this file is built using public information but using
preliminary LAUS data for June of the current year, archives of these
files are not publicly available but also do not contain confidential
information. Future versions of ASUloadR may build these input files
directly, but currently the state-specific input file is required.

ASUs are required to meet three elements to be considered. First, the
region must be geographically contiguous (including corner-to-corner
intersections). Second, the region must have a population of at least
10,000. Third, the unemployment rate in the region must be at least
6.5%. The methodology in **BLSloadR** looks at each census tract with an
unemployment rate of at least 6.45%, then adds the adjacent tract with
the next-highest unemployment rate (or a labor force of 0), and
continues until the unemployment rate in the combined region is \<6.45%.
It then removes the last-added tract, designates the region as an ASU,
and continues with the next-highest remaining unused tract in the state.
It continues building regions until there are no remaining tracts with a
rate of at least 6.45%, then stops.

**Using ASUloadR**

The basic functionality of **ASUloadR** is simple. First, install the
package. Second, call the `launch_ASUloadR()` function. If you prefer,
you don’t even have to load the package into your library, just call it
directly with `ASUloadR::launch_ASUloadR()`. By default, this will
launch the **ASUloadR** Shiny app in your default browser window.

**Basic Navigation**

Within the app window, there are a series of tabs across the top. These
control the basic navigation within the app. The functionality of each
tab will be described in detail below.

-   Data Initialization: this is where you load the Excel file from BLS.

-   Load Initial ASU: here you use the data from BLS to generate an
    initial list of potential ASUs.

-   Modify ASU Selections: this is the primary window you will interact
    with. It allows for the manipulation and refinement of the data.

-   Save and Load Data: this allows you to save the current state of the
    modified data and maps to be loaded later. If you have already saved
    data, you can come straight here to load that map.

-   ASU Review and Finalization: this tab contains tools to review the
    summarized ASUs, to generate an output CSV file to review individual
    tracts, and to generate a batch TXT file that can be uploaded to
    BLS.

**Data Initialization**

To begin the ASU building process, click the `Browse` button on the left
side of the page and select a XLSX file that has the BLS ASU data input structure. Once a file has been selected, an overview of the file
will appear on the right to confirm the file has successfully loaded.
You may review the contents of the columns to ensure that data appears
to be loaded correctly. This script assumes the columns are maintained
in a consistent order by BLS - changes to the structure of the file will
require updates to the structure of this code.

When review is complete, continue to the next tab - Load Initial ASU.

**Load Initial ASU**

There are two options available to the user at this stage.  The **Tract Hunter** is a process that will iteratively build ASU regions by seeding an initial map, then comparing potential targeted tracts to add or remove, with the goal of achieving the maximum level of unemployment within all ASUs. Tract Hunter includes logic to only allow ASUs that meet the minimum 10,000 population threshold.

The original **Simple Snake** methodology starts from tracts with an unemployment rate of at least 6.45%, then sequentially adding the adjacent tract with the highest unemployment rate until the combined region is less than 6.45%. Because this starts from single tracts, it does not consider whether the combined population qualifies as an ASU.

If the state being loaded is a New England state, you will see an additional option to select the year to download.  Because the Census Bureau only maintains NECTA-based census tracts for 2021 and earlier, using the default settings may cause the app to crash if your Excel file uses these older GEOIDs.

To begin the ASU designation process, choose a methodology.  Then, click the
`Load Tracts and Initialize ASU` button. This will download the appropriate shapefiles from the Census and execute the tract-by-tract ASU building process. Small states may see this process run in under 20 seconds. The largest states may take up to 5 minutes. When the process is complete, the app will render a map to on the right side of the page. The number of colors on this map is limited to 8, so if more than 8 potential ASUs are identified, more than one ASU will use the same color.

If using the Tract Hunter, use the **Run Hunter** and **Combine Groups** buttons to allow the algorithm to attempt to improve the existing ASUs.

In addition, note that a table of the potential ASUs will appear below
the button. This will give the analyst a sense of how many tracts may be
worth merging into larger ASUs. In general, regions with 3 or fewer
tracts are unlikely to meet the population threshold to qualify as an
ASU.

To begin manually manipulating the data, proceed to the next tab, Modify ASU
Selections. Or, if the number of modifications is large or the state
takes a long time to run, skip ahead to perform an initial save of the
data on Save and Load Data.

**Modify ASU Selections**

This tab is where all edits to the ASU selections are made. A number of
tools are provided to aid in the optimization of the ASUs. In general,
*selected* tracts will be outlined in red on the map.  A summary of selected tracts as well as aggregate statistics will be displayed on the right of the map. Clicking on a row of that table will _highlight_ that tract in black.

-   Hover over the map. Hovering the mouse over the map will display
    information about that tract useful to the selection process.

-   Click on the map. Clicking on the map will select, or unselect, a
    particular tract.

-   Select ASU Number: This dropdown allows you to select all the tracts
    in a particular ASU. If you select None, this will effectively clear
    all selected tracts.

-   Change ASU Value / Update Selected Tracts: This is how you change
    the pre-assigned ASU number. Enter the numeric value in the box
    under *Change ASU Value:* and then click the *Update Selected
    Tracts* to change the value. The numeric value remains in the box,
    providing a convenient way to keep changing tracts or groups of
    tracts to the same ASU. Further, changing the ASU number to 0 is how
    selected tracts are removed from any ASUs.

-   Percentile Threshold: This allows you to examine the tracts in your current selection with either high or low unemployment rates.  This is useful for identifying tracts outside of current ASUs that you may wish to include in an ASU or identifying tracts inside of current ASUs that you may with to drop.  Please choose whether you want to highlight Low or High unemployment tracts and enter a number in the Percentile Threshold box to highlight the top or bottom X% of tracts (X is the number you enter).  For example, if you have 200 tracts selected and choose 5 as your threshold and High unemployment, clicking the **Highlight Tracts** button will turn the color of the 10 tracts with the highest unemployment rates black.  Selecting **Clear Highlights** will clear all current highlighting (including highlights from clicking individual tracts in the selection summary).

-   Enter a GEOID / Select a Single Tract: This functionality is most
    useful when using the CSV output that this app generates on the
    **ASU Review and Finalization** tab. Given the 11-character GEOID,
    you can input that to highlight a single tract to examine where it
    fits. This can be helpful for fine-tuning - for example, reviewing the
    highest-unemployment tracts not included in an ASU to ensure they
    cannot be connected in to improve the ASU.

-   Reset to Initial Data: This button will reset all changes you have
    made to the state of the map after the **Load Initial ASU** process.
    For when you’ve just broken everything and want to start over. Use
    with caution!

**Save and Load Data**

This tab contains some simple options to help save and load the current
state of the map. While Nevada had only 6 initial ASUs to review other
states may have over 100! This will save the background data of the app
as an RDS file, or load data from an RDS file.

To specify a directory other than your working directory, paste that
directory into the `Save Directory Path` box.

**ASU Review and Finalization**

This will typically be the last screen in the process. Here, you may
test the ASUs you have created against the required numeric thresholds
using `Generate ASU Summary` - this is most useful for validating edge
cases, when the calculated aggregate ASU rate is less than but rounds up
to 6.45. Because the criteria for an ASU is an unemployment rate of
6.5%, a rate of 6.449% will not qualify. The TRUE/FALSE outputs in the
table provide the most reliable test for whether the ASU will qualify.

Generate LSS .txt File and Create Summary CSV will both create files in
the directory specified in the **Save and Load Data** tab (or your
working directory). The LSS TXT file should be formatted to be able to
upload to LSS directly once the ASUs are completed. The Summary CSV file
provides a handy output of all selected tracts and a useful tool to
review the selections for high-unemployment tracts that were not
included.
